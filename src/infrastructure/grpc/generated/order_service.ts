// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.32.1
// source: order_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "order_service";

/** Structured error message */
export interface Error {
  /** e.g., "RESOURCE_NOT_FOUND", "INVALID_ARGUMENT", "UNAUTHENTICATED" */
  code: string;
  /** Human-readable error message */
  message: string;
  /** Optional detailed error information */
  details: ErrorDetail[];
}

/** Detailed error information */
export interface ErrorDetail {
  /** Field name that caused the error */
  field: string;
  /** Field-specific error message */
  message: string;
}

export interface OrderItemsData {
  courseId: string;
  price: number;
}

export interface PaymentDetailsData {
  paymentId: string;
  provider: string;
  providerOrderId?: string | undefined;
  paymentStatus: string;
  updatedAt: string;
}

export interface MoneyData {
  price: number;
  currency: string;
  discount: number;
  subTotal: number;
}

export interface OrderData {
  id: string;
  userId: string;
  items: OrderItemsData[];
  paymentDetails?: PaymentDetailsData | undefined;
  amount: MoneyData | undefined;
  status: string;
  createdAt: string;
  updatedAt: string;
}

/** Success message for PlaceOrder */
export interface PlaceOrderSuccess {
  id: string;
  userId: string;
  courseIds: string[];
  totalAmount: number;
  currency: string;
  status: string;
  createdAt: string;
  updatedAt: string;
}

/** Success message for BookSession */
export interface BookSessionSuccess {
  id: string;
  userId: string;
  sessionId: string;
  amount: number;
  currency: string;
  status: string;
  createdAt: string;
  updatedAt: string;
}

export interface PlaceOrderRequest {
  userId: string;
  couponCode?: string | undefined;
  courseIds: string[];
}

export interface OrdersSuccess {
  orders: OrderData[];
}

export interface OrderSuccess {
  order: OrderData | undefined;
}

export interface OrderResponse {
  success?: OrderSuccess | undefined;
  error?: Error | undefined;
}

export interface OrdersResponse {
  success?: OrdersSuccess | undefined;
  error?: Error | undefined;
}

export interface BookSessionRequest {
  userId: string;
  sessionId: string;
}

export interface GetOrderByIdRequest {
  orderId: string;
  userId: string;
}

export interface GetOrderByUserIdRequest {
  userId: string;
}

export interface BookSessionResponse {
  success?: BookSessionSuccess | undefined;
  error?: Error | undefined;
}

function createBaseError(): Error {
  return { code: "", message: "", details: [] };
}

export const Error: MessageFns<Error> = {
  encode(message: Error, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.details) {
      ErrorDetail.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Error {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.details.push(ErrorDetail.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      details: globalThis.Array.isArray(object?.details) ? object.details.map((e: any) => ErrorDetail.fromJSON(e)) : [],
    };
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.details?.length) {
      obj.details = message.details.map((e) => ErrorDetail.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Error>, I>>(base?: I): Error {
    return Error.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Error>, I>>(object: I): Error {
    const message = createBaseError();
    message.code = object.code ?? "";
    message.message = object.message ?? "";
    message.details = object.details?.map((e) => ErrorDetail.fromPartial(e)) || [];
    return message;
  },
};

function createBaseErrorDetail(): ErrorDetail {
  return { field: "", message: "" };
}

export const ErrorDetail: MessageFns<ErrorDetail> = {
  encode(message: ErrorDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorDetail {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ErrorDetail): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorDetail>, I>>(base?: I): ErrorDetail {
    return ErrorDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorDetail>, I>>(object: I): ErrorDetail {
    const message = createBaseErrorDetail();
    message.field = object.field ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseOrderItemsData(): OrderItemsData {
  return { courseId: "", price: 0 };
}

export const OrderItemsData: MessageFns<OrderItemsData> = {
  encode(message: OrderItemsData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.courseId !== "") {
      writer.uint32(10).string(message.courseId);
    }
    if (message.price !== 0) {
      writer.uint32(21).float(message.price);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderItemsData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderItemsData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.courseId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.price = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderItemsData {
    return {
      courseId: isSet(object.courseId) ? globalThis.String(object.courseId) : "",
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
    };
  },

  toJSON(message: OrderItemsData): unknown {
    const obj: any = {};
    if (message.courseId !== "") {
      obj.courseId = message.courseId;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderItemsData>, I>>(base?: I): OrderItemsData {
    return OrderItemsData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderItemsData>, I>>(object: I): OrderItemsData {
    const message = createBaseOrderItemsData();
    message.courseId = object.courseId ?? "";
    message.price = object.price ?? 0;
    return message;
  },
};

function createBasePaymentDetailsData(): PaymentDetailsData {
  return { paymentId: "", provider: "", providerOrderId: undefined, paymentStatus: "", updatedAt: "" };
}

export const PaymentDetailsData: MessageFns<PaymentDetailsData> = {
  encode(message: PaymentDetailsData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentId !== "") {
      writer.uint32(10).string(message.paymentId);
    }
    if (message.provider !== "") {
      writer.uint32(18).string(message.provider);
    }
    if (message.providerOrderId !== undefined) {
      writer.uint32(26).string(message.providerOrderId);
    }
    if (message.paymentStatus !== "") {
      writer.uint32(34).string(message.paymentStatus);
    }
    if (message.updatedAt !== "") {
      writer.uint32(42).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentDetailsData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentDetailsData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.provider = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.providerOrderId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.paymentStatus = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentDetailsData {
    return {
      paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "",
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      providerOrderId: isSet(object.providerOrderId) ? globalThis.String(object.providerOrderId) : undefined,
      paymentStatus: isSet(object.paymentStatus) ? globalThis.String(object.paymentStatus) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: PaymentDetailsData): unknown {
    const obj: any = {};
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.providerOrderId !== undefined) {
      obj.providerOrderId = message.providerOrderId;
    }
    if (message.paymentStatus !== "") {
      obj.paymentStatus = message.paymentStatus;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentDetailsData>, I>>(base?: I): PaymentDetailsData {
    return PaymentDetailsData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentDetailsData>, I>>(object: I): PaymentDetailsData {
    const message = createBasePaymentDetailsData();
    message.paymentId = object.paymentId ?? "";
    message.provider = object.provider ?? "";
    message.providerOrderId = object.providerOrderId ?? undefined;
    message.paymentStatus = object.paymentStatus ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseMoneyData(): MoneyData {
  return { price: 0, currency: "", discount: 0, subTotal: 0 };
}

export const MoneyData: MessageFns<MoneyData> = {
  encode(message: MoneyData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.price !== 0) {
      writer.uint32(13).float(message.price);
    }
    if (message.currency !== "") {
      writer.uint32(18).string(message.currency);
    }
    if (message.discount !== 0) {
      writer.uint32(29).float(message.discount);
    }
    if (message.subTotal !== 0) {
      writer.uint32(37).float(message.subTotal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoneyData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoneyData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.price = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.discount = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.subTotal = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MoneyData {
    return {
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      discount: isSet(object.discount) ? globalThis.Number(object.discount) : 0,
      subTotal: isSet(object.subTotal) ? globalThis.Number(object.subTotal) : 0,
    };
  },

  toJSON(message: MoneyData): unknown {
    const obj: any = {};
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.discount !== 0) {
      obj.discount = message.discount;
    }
    if (message.subTotal !== 0) {
      obj.subTotal = message.subTotal;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MoneyData>, I>>(base?: I): MoneyData {
    return MoneyData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MoneyData>, I>>(object: I): MoneyData {
    const message = createBaseMoneyData();
    message.price = object.price ?? 0;
    message.currency = object.currency ?? "";
    message.discount = object.discount ?? 0;
    message.subTotal = object.subTotal ?? 0;
    return message;
  },
};

function createBaseOrderData(): OrderData {
  return {
    id: "",
    userId: "",
    items: [],
    paymentDetails: undefined,
    amount: undefined,
    status: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const OrderData: MessageFns<OrderData> = {
  encode(message: OrderData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    for (const v of message.items) {
      OrderItemsData.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.paymentDetails !== undefined) {
      PaymentDetailsData.encode(message.paymentDetails, writer.uint32(90).fork()).join();
    }
    if (message.amount !== undefined) {
      MoneyData.encode(message.amount, writer.uint32(34).fork()).join();
    }
    if (message.status !== "") {
      writer.uint32(50).string(message.status);
    }
    if (message.createdAt !== "") {
      writer.uint32(58).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(66).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.items.push(OrderItemsData.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.paymentDetails = PaymentDetailsData.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = MoneyData.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderData {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => OrderItemsData.fromJSON(e)) : [],
      paymentDetails: isSet(object.paymentDetails) ? PaymentDetailsData.fromJSON(object.paymentDetails) : undefined,
      amount: isSet(object.amount) ? MoneyData.fromJSON(object.amount) : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: OrderData): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => OrderItemsData.toJSON(e));
    }
    if (message.paymentDetails !== undefined) {
      obj.paymentDetails = PaymentDetailsData.toJSON(message.paymentDetails);
    }
    if (message.amount !== undefined) {
      obj.amount = MoneyData.toJSON(message.amount);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderData>, I>>(base?: I): OrderData {
    return OrderData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderData>, I>>(object: I): OrderData {
    const message = createBaseOrderData();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.items = object.items?.map((e) => OrderItemsData.fromPartial(e)) || [];
    message.paymentDetails = (object.paymentDetails !== undefined && object.paymentDetails !== null)
      ? PaymentDetailsData.fromPartial(object.paymentDetails)
      : undefined;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? MoneyData.fromPartial(object.amount)
      : undefined;
    message.status = object.status ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBasePlaceOrderSuccess(): PlaceOrderSuccess {
  return { id: "", userId: "", courseIds: [], totalAmount: 0, currency: "", status: "", createdAt: "", updatedAt: "" };
}

export const PlaceOrderSuccess: MessageFns<PlaceOrderSuccess> = {
  encode(message: PlaceOrderSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    for (const v of message.courseIds) {
      writer.uint32(26).string(v!);
    }
    if (message.totalAmount !== 0) {
      writer.uint32(37).float(message.totalAmount);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(50).string(message.status);
    }
    if (message.createdAt !== "") {
      writer.uint32(58).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(66).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlaceOrderSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlaceOrderSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.courseIds.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.totalAmount = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlaceOrderSuccess {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      courseIds: globalThis.Array.isArray(object?.courseIds)
        ? object.courseIds.map((e: any) => globalThis.String(e))
        : [],
      totalAmount: isSet(object.totalAmount) ? globalThis.Number(object.totalAmount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: PlaceOrderSuccess): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.courseIds?.length) {
      obj.courseIds = message.courseIds;
    }
    if (message.totalAmount !== 0) {
      obj.totalAmount = message.totalAmount;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlaceOrderSuccess>, I>>(base?: I): PlaceOrderSuccess {
    return PlaceOrderSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlaceOrderSuccess>, I>>(object: I): PlaceOrderSuccess {
    const message = createBasePlaceOrderSuccess();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.courseIds = object.courseIds?.map((e) => e) || [];
    message.totalAmount = object.totalAmount ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseBookSessionSuccess(): BookSessionSuccess {
  return { id: "", userId: "", sessionId: "", amount: 0, currency: "", status: "", createdAt: "", updatedAt: "" };
}

export const BookSessionSuccess: MessageFns<BookSessionSuccess> = {
  encode(message: BookSessionSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.sessionId !== "") {
      writer.uint32(26).string(message.sessionId);
    }
    if (message.amount !== 0) {
      writer.uint32(37).float(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(50).string(message.status);
    }
    if (message.createdAt !== "") {
      writer.uint32(58).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(66).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BookSessionSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBookSessionSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.amount = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BookSessionSuccess {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: BookSessionSuccess): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BookSessionSuccess>, I>>(base?: I): BookSessionSuccess {
    return BookSessionSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BookSessionSuccess>, I>>(object: I): BookSessionSuccess {
    const message = createBaseBookSessionSuccess();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.sessionId = object.sessionId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBasePlaceOrderRequest(): PlaceOrderRequest {
  return { userId: "", couponCode: undefined, courseIds: [] };
}

export const PlaceOrderRequest: MessageFns<PlaceOrderRequest> = {
  encode(message: PlaceOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.couponCode !== undefined) {
      writer.uint32(26).string(message.couponCode);
    }
    for (const v of message.courseIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlaceOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlaceOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.couponCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.courseIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlaceOrderRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      couponCode: isSet(object.couponCode) ? globalThis.String(object.couponCode) : undefined,
      courseIds: globalThis.Array.isArray(object?.courseIds)
        ? object.courseIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: PlaceOrderRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.couponCode !== undefined) {
      obj.couponCode = message.couponCode;
    }
    if (message.courseIds?.length) {
      obj.courseIds = message.courseIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlaceOrderRequest>, I>>(base?: I): PlaceOrderRequest {
    return PlaceOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlaceOrderRequest>, I>>(object: I): PlaceOrderRequest {
    const message = createBasePlaceOrderRequest();
    message.userId = object.userId ?? "";
    message.couponCode = object.couponCode ?? undefined;
    message.courseIds = object.courseIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseOrdersSuccess(): OrdersSuccess {
  return { orders: [] };
}

export const OrdersSuccess: MessageFns<OrdersSuccess> = {
  encode(message: OrdersSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.orders) {
      OrderData.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrdersSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrdersSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orders.push(OrderData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrdersSuccess {
    return {
      orders: globalThis.Array.isArray(object?.orders) ? object.orders.map((e: any) => OrderData.fromJSON(e)) : [],
    };
  },

  toJSON(message: OrdersSuccess): unknown {
    const obj: any = {};
    if (message.orders?.length) {
      obj.orders = message.orders.map((e) => OrderData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrdersSuccess>, I>>(base?: I): OrdersSuccess {
    return OrdersSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrdersSuccess>, I>>(object: I): OrdersSuccess {
    const message = createBaseOrdersSuccess();
    message.orders = object.orders?.map((e) => OrderData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOrderSuccess(): OrderSuccess {
  return { order: undefined };
}

export const OrderSuccess: MessageFns<OrderSuccess> = {
  encode(message: OrderSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.order !== undefined) {
      OrderData.encode(message.order, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.order = OrderData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderSuccess {
    return { order: isSet(object.order) ? OrderData.fromJSON(object.order) : undefined };
  },

  toJSON(message: OrderSuccess): unknown {
    const obj: any = {};
    if (message.order !== undefined) {
      obj.order = OrderData.toJSON(message.order);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderSuccess>, I>>(base?: I): OrderSuccess {
    return OrderSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderSuccess>, I>>(object: I): OrderSuccess {
    const message = createBaseOrderSuccess();
    message.order = (object.order !== undefined && object.order !== null)
      ? OrderData.fromPartial(object.order)
      : undefined;
    return message;
  },
};

function createBaseOrderResponse(): OrderResponse {
  return { success: undefined, error: undefined };
}

export const OrderResponse: MessageFns<OrderResponse> = {
  encode(message: OrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      OrderSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = OrderSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderResponse {
    return {
      success: isSet(object.success) ? OrderSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: OrderResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = OrderSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderResponse>, I>>(base?: I): OrderResponse {
    return OrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderResponse>, I>>(object: I): OrderResponse {
    const message = createBaseOrderResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? OrderSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseOrdersResponse(): OrdersResponse {
  return { success: undefined, error: undefined };
}

export const OrdersResponse: MessageFns<OrdersResponse> = {
  encode(message: OrdersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      OrdersSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrdersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = OrdersSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrdersResponse {
    return {
      success: isSet(object.success) ? OrdersSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: OrdersResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = OrdersSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrdersResponse>, I>>(base?: I): OrdersResponse {
    return OrdersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrdersResponse>, I>>(object: I): OrdersResponse {
    const message = createBaseOrdersResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? OrdersSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseBookSessionRequest(): BookSessionRequest {
  return { userId: "", sessionId: "" };
}

export const BookSessionRequest: MessageFns<BookSessionRequest> = {
  encode(message: BookSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BookSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBookSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BookSessionRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
    };
  },

  toJSON(message: BookSessionRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BookSessionRequest>, I>>(base?: I): BookSessionRequest {
    return BookSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BookSessionRequest>, I>>(object: I): BookSessionRequest {
    const message = createBaseBookSessionRequest();
    message.userId = object.userId ?? "";
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseGetOrderByIdRequest(): GetOrderByIdRequest {
  return { orderId: "", userId: "" };
}

export const GetOrderByIdRequest: MessageFns<GetOrderByIdRequest> = {
  encode(message: GetOrderByIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderByIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrderByIdRequest {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
    };
  },

  toJSON(message: GetOrderByIdRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrderByIdRequest>, I>>(base?: I): GetOrderByIdRequest {
    return GetOrderByIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrderByIdRequest>, I>>(object: I): GetOrderByIdRequest {
    const message = createBaseGetOrderByIdRequest();
    message.orderId = object.orderId ?? "";
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseGetOrderByUserIdRequest(): GetOrderByUserIdRequest {
  return { userId: "" };
}

export const GetOrderByUserIdRequest: MessageFns<GetOrderByUserIdRequest> = {
  encode(message: GetOrderByUserIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderByUserIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderByUserIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrderByUserIdRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: GetOrderByUserIdRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrderByUserIdRequest>, I>>(base?: I): GetOrderByUserIdRequest {
    return GetOrderByUserIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrderByUserIdRequest>, I>>(object: I): GetOrderByUserIdRequest {
    const message = createBaseGetOrderByUserIdRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseBookSessionResponse(): BookSessionResponse {
  return { success: undefined, error: undefined };
}

export const BookSessionResponse: MessageFns<BookSessionResponse> = {
  encode(message: BookSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      BookSessionSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BookSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBookSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = BookSessionSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BookSessionResponse {
    return {
      success: isSet(object.success) ? BookSessionSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: BookSessionResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = BookSessionSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BookSessionResponse>, I>>(base?: I): BookSessionResponse {
    return BookSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BookSessionResponse>, I>>(object: I): BookSessionResponse {
    const message = createBaseBookSessionResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? BookSessionSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

export type OrderServiceService = typeof OrderServiceService;
export const OrderServiceService = {
  placeOrder: {
    path: "/order_service.OrderService/PlaceOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PlaceOrderRequest) => Buffer.from(PlaceOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PlaceOrderRequest.decode(value),
    responseSerialize: (value: OrderResponse) => Buffer.from(OrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => OrderResponse.decode(value),
  },
  bookSession: {
    path: "/order_service.OrderService/BookSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BookSessionRequest) => Buffer.from(BookSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BookSessionRequest.decode(value),
    responseSerialize: (value: BookSessionResponse) => Buffer.from(BookSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BookSessionResponse.decode(value),
  },
  getOrderById: {
    path: "/order_service.OrderService/GetOrderById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetOrderByIdRequest) => Buffer.from(GetOrderByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetOrderByIdRequest.decode(value),
    responseSerialize: (value: OrderResponse) => Buffer.from(OrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => OrderResponse.decode(value),
  },
  getOrdersByUserId: {
    path: "/order_service.OrderService/GetOrdersByUserId",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetOrderByUserIdRequest) => Buffer.from(GetOrderByUserIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetOrderByUserIdRequest.decode(value),
    responseSerialize: (value: OrdersResponse) => Buffer.from(OrdersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => OrdersResponse.decode(value),
  },
} as const;

export interface OrderServiceServer extends UntypedServiceImplementation {
  placeOrder: handleUnaryCall<PlaceOrderRequest, OrderResponse>;
  bookSession: handleUnaryCall<BookSessionRequest, BookSessionResponse>;
  getOrderById: handleUnaryCall<GetOrderByIdRequest, OrderResponse>;
  getOrdersByUserId: handleUnaryCall<GetOrderByUserIdRequest, OrdersResponse>;
}

export interface OrderServiceClient extends Client {
  placeOrder(
    request: PlaceOrderRequest,
    callback: (error: ServiceError | null, response: OrderResponse) => void,
  ): ClientUnaryCall;
  placeOrder(
    request: PlaceOrderRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: OrderResponse) => void,
  ): ClientUnaryCall;
  placeOrder(
    request: PlaceOrderRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: OrderResponse) => void,
  ): ClientUnaryCall;
  bookSession(
    request: BookSessionRequest,
    callback: (error: ServiceError | null, response: BookSessionResponse) => void,
  ): ClientUnaryCall;
  bookSession(
    request: BookSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BookSessionResponse) => void,
  ): ClientUnaryCall;
  bookSession(
    request: BookSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BookSessionResponse) => void,
  ): ClientUnaryCall;
  getOrderById(
    request: GetOrderByIdRequest,
    callback: (error: ServiceError | null, response: OrderResponse) => void,
  ): ClientUnaryCall;
  getOrderById(
    request: GetOrderByIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: OrderResponse) => void,
  ): ClientUnaryCall;
  getOrderById(
    request: GetOrderByIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: OrderResponse) => void,
  ): ClientUnaryCall;
  getOrdersByUserId(
    request: GetOrderByUserIdRequest,
    callback: (error: ServiceError | null, response: OrdersResponse) => void,
  ): ClientUnaryCall;
  getOrdersByUserId(
    request: GetOrderByUserIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: OrdersResponse) => void,
  ): ClientUnaryCall;
  getOrdersByUserId(
    request: GetOrderByUserIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: OrdersResponse) => void,
  ): ClientUnaryCall;
}

export const OrderServiceClient = makeGenericClientConstructor(
  OrderServiceService,
  "order_service.OrderService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): OrderServiceClient;
  service: typeof OrderServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
