// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.1
//   protoc               v6.33.4
// source: payment_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";
import { Provider } from "./payment/common";
import { PayPalPaymentSession, PayPalResolveRequest } from "./payment/types/paypal";
import { RazorpayPaymentSession, RazorpayResolveRequest } from "./payment/types/razorpay";
import { StripePaymentSession, StripeResolveRequest } from "./payment/types/stripe";

export const protobufPackage = "payment_service";

/** Structured error message */
export interface Error {
  /** e.g., "RESOURCE_NOT_FOUND", "INVALID_ARGUMENT", "UNAUTHENTICATED" */
  code: string;
  /** Human-readable error message */
  message: string;
  /** Optional detailed error information */
  details: ErrorDetail[];
}

/** Detailed error information */
export interface ErrorDetail {
  /** Field name that caused the error */
  field: string;
  /** Field-specific error message */
  message: string;
}

export interface CreatePaymentRequest {
  provider: Provider;
  userId: string;
  orderId: string;
  /** For ensuring idempotency */
  idempotencyKey: string;
  successUrl?: string | undefined;
  cancelUrl?: string | undefined;
}

export interface CreatePaymentResponse {
  success?: CreatePaymentSuccess | undefined;
  error?: Error | undefined;
}

export interface CreatePaymentSuccess {
  provider: Provider;
  paymentId: string;
  status: string;
  orderId: string;
  stripe?: StripePaymentSession | undefined;
  razorpay?: RazorpayPaymentSession | undefined;
  paypal?: PayPalPaymentSession | undefined;
}

export interface ResolvePaymentRequest {
  provider: Provider;
  stripe?: StripeResolveRequest | undefined;
  razorpay?: RazorpayResolveRequest | undefined;
  paypal?: PayPalResolveRequest | undefined;
}

export interface CancelPaymentRequest {
  provider: Provider;
  providerOrderId: string;
}

export interface ResolvePaymentResponse {
  success?: ResolvePaymentSuccess | undefined;
  error?: Error | undefined;
}

export interface CancelPaymentResponse {
  success?: CancelPaymentSuccess | undefined;
  error?: Error | undefined;
}

export interface GetPaymentResponse {
  success?: PaymentData | undefined;
  error?: Error | undefined;
}

export interface ResolvePaymentSuccess {
  status: string;
  paymentId: string;
  orderId: string;
  isResolved: boolean;
}

export interface CancelPaymentSuccess {
  status: string;
  paymentId: string;
  providerOrderId: string;
}

export interface GetPaymentRequest {
  paymentId: string;
}

export interface GetPaymentSuccess {
  paymentId: string;
  provider: Provider;
  status: string;
  amount: number;
  currency: string;
  createdAt: string;
  updatedAt: string;
  stripe?: StripePaymentSession | undefined;
  razorpay?: RazorpayPaymentSession | undefined;
  paypal?: PayPalPaymentSession | undefined;
}

export interface PaymentData {
  paymentId: string;
  provider: Provider;
  status: string;
  amount: number;
  currency: string;
  orderId: string;
  providerOrderId: string;
  createdAt: string;
  updatedAt: string;
}

/** Health check request (for monitoring) */
export interface HealthCheckRequest {
}

/** Health check response */
export interface HealthCheckResponse {
  /** e.g., "HEALTHY", "UNHEALTHY" */
  status: string;
}

export const PAYMENT_SERVICE_PACKAGE_NAME = "payment_service";

function createBaseError(): Error {
  return { code: "", message: "", details: [] };
}

export const Error: MessageFns<Error> = {
  encode(message: Error, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.details) {
      ErrorDetail.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Error {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.details.push(ErrorDetail.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseErrorDetail(): ErrorDetail {
  return { field: "", message: "" };
}

export const ErrorDetail: MessageFns<ErrorDetail> = {
  encode(message: ErrorDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreatePaymentRequest(): CreatePaymentRequest {
  return { provider: 0, userId: "", orderId: "", idempotencyKey: "" };
}

export const CreatePaymentRequest: MessageFns<CreatePaymentRequest> = {
  encode(message: CreatePaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== 0) {
      writer.uint32(8).int32(message.provider);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.orderId !== "") {
      writer.uint32(26).string(message.orderId);
    }
    if (message.idempotencyKey !== "") {
      writer.uint32(42).string(message.idempotencyKey);
    }
    if (message.successUrl !== undefined) {
      writer.uint32(58).string(message.successUrl);
    }
    if (message.cancelUrl !== undefined) {
      writer.uint32(66).string(message.cancelUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.provider = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.successUrl = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.cancelUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreatePaymentResponse(): CreatePaymentResponse {
  return {};
}

export const CreatePaymentResponse: MessageFns<CreatePaymentResponse> = {
  encode(message: CreatePaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      CreatePaymentSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = CreatePaymentSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreatePaymentSuccess(): CreatePaymentSuccess {
  return { provider: 0, paymentId: "", status: "", orderId: "" };
}

export const CreatePaymentSuccess: MessageFns<CreatePaymentSuccess> = {
  encode(message: CreatePaymentSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== 0) {
      writer.uint32(8).int32(message.provider);
    }
    if (message.paymentId !== "") {
      writer.uint32(82).string(message.paymentId);
    }
    if (message.status !== "") {
      writer.uint32(90).string(message.status);
    }
    if (message.orderId !== "") {
      writer.uint32(98).string(message.orderId);
    }
    if (message.stripe !== undefined) {
      StripePaymentSession.encode(message.stripe, writer.uint32(18).fork()).join();
    }
    if (message.razorpay !== undefined) {
      RazorpayPaymentSession.encode(message.razorpay, writer.uint32(26).fork()).join();
    }
    if (message.paypal !== undefined) {
      PayPalPaymentSession.encode(message.paypal, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePaymentSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePaymentSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.provider = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stripe = StripePaymentSession.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.razorpay = RazorpayPaymentSession.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.paypal = PayPalPaymentSession.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseResolvePaymentRequest(): ResolvePaymentRequest {
  return { provider: 0 };
}

export const ResolvePaymentRequest: MessageFns<ResolvePaymentRequest> = {
  encode(message: ResolvePaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== 0) {
      writer.uint32(8).int32(message.provider);
    }
    if (message.stripe !== undefined) {
      StripeResolveRequest.encode(message.stripe, writer.uint32(18).fork()).join();
    }
    if (message.razorpay !== undefined) {
      RazorpayResolveRequest.encode(message.razorpay, writer.uint32(26).fork()).join();
    }
    if (message.paypal !== undefined) {
      PayPalResolveRequest.encode(message.paypal, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResolvePaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolvePaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.provider = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stripe = StripeResolveRequest.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.razorpay = RazorpayResolveRequest.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.paypal = PayPalResolveRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCancelPaymentRequest(): CancelPaymentRequest {
  return { provider: 0, providerOrderId: "" };
}

export const CancelPaymentRequest: MessageFns<CancelPaymentRequest> = {
  encode(message: CancelPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== 0) {
      writer.uint32(8).int32(message.provider);
    }
    if (message.providerOrderId !== "") {
      writer.uint32(18).string(message.providerOrderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.provider = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerOrderId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseResolvePaymentResponse(): ResolvePaymentResponse {
  return {};
}

export const ResolvePaymentResponse: MessageFns<ResolvePaymentResponse> = {
  encode(message: ResolvePaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      ResolvePaymentSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResolvePaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolvePaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = ResolvePaymentSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCancelPaymentResponse(): CancelPaymentResponse {
  return {};
}

export const CancelPaymentResponse: MessageFns<CancelPaymentResponse> = {
  encode(message: CancelPaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      CancelPaymentSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelPaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = CancelPaymentSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetPaymentResponse(): GetPaymentResponse {
  return {};
}

export const GetPaymentResponse: MessageFns<GetPaymentResponse> = {
  encode(message: GetPaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      PaymentData.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = PaymentData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseResolvePaymentSuccess(): ResolvePaymentSuccess {
  return { status: "", paymentId: "", orderId: "", isResolved: false };
}

export const ResolvePaymentSuccess: MessageFns<ResolvePaymentSuccess> = {
  encode(message: ResolvePaymentSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.paymentId !== "") {
      writer.uint32(18).string(message.paymentId);
    }
    if (message.orderId !== "") {
      writer.uint32(34).string(message.orderId);
    }
    if (message.isResolved !== false) {
      writer.uint32(24).bool(message.isResolved);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResolvePaymentSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolvePaymentSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isResolved = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCancelPaymentSuccess(): CancelPaymentSuccess {
  return { status: "", paymentId: "", providerOrderId: "" };
}

export const CancelPaymentSuccess: MessageFns<CancelPaymentSuccess> = {
  encode(message: CancelPaymentSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.paymentId !== "") {
      writer.uint32(18).string(message.paymentId);
    }
    if (message.providerOrderId !== "") {
      writer.uint32(26).string(message.providerOrderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelPaymentSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelPaymentSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.providerOrderId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetPaymentRequest(): GetPaymentRequest {
  return { paymentId: "" };
}

export const GetPaymentRequest: MessageFns<GetPaymentRequest> = {
  encode(message: GetPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentId !== "") {
      writer.uint32(10).string(message.paymentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetPaymentSuccess(): GetPaymentSuccess {
  return { paymentId: "", provider: 0, status: "", amount: 0, currency: "", createdAt: "", updatedAt: "" };
}

export const GetPaymentSuccess: MessageFns<GetPaymentSuccess> = {
  encode(message: GetPaymentSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentId !== "") {
      writer.uint32(10).string(message.paymentId);
    }
    if (message.provider !== 0) {
      writer.uint32(16).int32(message.provider);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.amount !== 0) {
      writer.uint32(32).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.createdAt !== "") {
      writer.uint32(50).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(58).string(message.updatedAt);
    }
    if (message.stripe !== undefined) {
      StripePaymentSession.encode(message.stripe, writer.uint32(66).fork()).join();
    }
    if (message.razorpay !== undefined) {
      RazorpayPaymentSession.encode(message.razorpay, writer.uint32(74).fork()).join();
    }
    if (message.paypal !== undefined) {
      PayPalPaymentSession.encode(message.paypal, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPaymentSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPaymentSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.provider = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.stripe = StripePaymentSession.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.razorpay = RazorpayPaymentSession.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.paypal = PayPalPaymentSession.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePaymentData(): PaymentData {
  return {
    paymentId: "",
    provider: 0,
    status: "",
    amount: 0,
    currency: "",
    orderId: "",
    providerOrderId: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const PaymentData: MessageFns<PaymentData> = {
  encode(message: PaymentData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentId !== "") {
      writer.uint32(10).string(message.paymentId);
    }
    if (message.provider !== 0) {
      writer.uint32(16).int32(message.provider);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.amount !== 0) {
      writer.uint32(32).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.orderId !== "") {
      writer.uint32(98).string(message.orderId);
    }
    if (message.providerOrderId !== "") {
      writer.uint32(90).string(message.providerOrderId);
    }
    if (message.createdAt !== "") {
      writer.uint32(50).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(58).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.provider = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.providerOrderId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return {};
}

export const HealthCheckRequest: MessageFns<HealthCheckRequest> = {
  encode(_: HealthCheckRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { status: "" };
}

export const HealthCheckResponse: MessageFns<HealthCheckResponse> = {
  encode(message: HealthCheckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface PaymentServiceClient {
  createPayment(request: CreatePaymentRequest): Observable<CreatePaymentResponse>;

  resolvePayment(request: ResolvePaymentRequest): Observable<ResolvePaymentResponse>;

  cancelPayment(request: CancelPaymentRequest): Observable<CancelPaymentResponse>;

  getPayment(request: GetPaymentRequest): Observable<GetPaymentResponse>;

  /** Health check endpoint */

  healthCheck(request: HealthCheckRequest): Observable<HealthCheckResponse>;
}

export interface PaymentServiceController {
  createPayment(
    request: CreatePaymentRequest,
  ): Promise<CreatePaymentResponse> | Observable<CreatePaymentResponse> | CreatePaymentResponse;

  resolvePayment(
    request: ResolvePaymentRequest,
  ): Promise<ResolvePaymentResponse> | Observable<ResolvePaymentResponse> | ResolvePaymentResponse;

  cancelPayment(
    request: CancelPaymentRequest,
  ): Promise<CancelPaymentResponse> | Observable<CancelPaymentResponse> | CancelPaymentResponse;

  getPayment(
    request: GetPaymentRequest,
  ): Promise<GetPaymentResponse> | Observable<GetPaymentResponse> | GetPaymentResponse;

  /** Health check endpoint */

  healthCheck(
    request: HealthCheckRequest,
  ): Promise<HealthCheckResponse> | Observable<HealthCheckResponse> | HealthCheckResponse;
}

export function PaymentServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["createPayment", "resolvePayment", "cancelPayment", "getPayment", "healthCheck"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("PaymentService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("PaymentService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const PAYMENT_SERVICE_NAME = "PaymentService";

export type PaymentServiceService = typeof PaymentServiceService;
export const PaymentServiceService = {
  createPayment: {
    path: "/payment_service.PaymentService/CreatePayment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePaymentRequest): Buffer => Buffer.from(CreatePaymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreatePaymentRequest => CreatePaymentRequest.decode(value),
    responseSerialize: (value: CreatePaymentResponse): Buffer =>
      Buffer.from(CreatePaymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreatePaymentResponse => CreatePaymentResponse.decode(value),
  },
  resolvePayment: {
    path: "/payment_service.PaymentService/ResolvePayment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResolvePaymentRequest): Buffer =>
      Buffer.from(ResolvePaymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ResolvePaymentRequest => ResolvePaymentRequest.decode(value),
    responseSerialize: (value: ResolvePaymentResponse): Buffer =>
      Buffer.from(ResolvePaymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ResolvePaymentResponse => ResolvePaymentResponse.decode(value),
  },
  cancelPayment: {
    path: "/payment_service.PaymentService/CancelPayment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelPaymentRequest): Buffer => Buffer.from(CancelPaymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CancelPaymentRequest => CancelPaymentRequest.decode(value),
    responseSerialize: (value: CancelPaymentResponse): Buffer =>
      Buffer.from(CancelPaymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CancelPaymentResponse => CancelPaymentResponse.decode(value),
  },
  getPayment: {
    path: "/payment_service.PaymentService/GetPayment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPaymentRequest): Buffer => Buffer.from(GetPaymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPaymentRequest => GetPaymentRequest.decode(value),
    responseSerialize: (value: GetPaymentResponse): Buffer => Buffer.from(GetPaymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetPaymentResponse => GetPaymentResponse.decode(value),
  },
  /** Health check endpoint */
  healthCheck: {
    path: "/payment_service.PaymentService/HealthCheck",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HealthCheckRequest): Buffer => Buffer.from(HealthCheckRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): HealthCheckRequest => HealthCheckRequest.decode(value),
    responseSerialize: (value: HealthCheckResponse): Buffer => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): HealthCheckResponse => HealthCheckResponse.decode(value),
  },
} as const;

export interface PaymentServiceServer extends UntypedServiceImplementation {
  createPayment: handleUnaryCall<CreatePaymentRequest, CreatePaymentResponse>;
  resolvePayment: handleUnaryCall<ResolvePaymentRequest, ResolvePaymentResponse>;
  cancelPayment: handleUnaryCall<CancelPaymentRequest, CancelPaymentResponse>;
  getPayment: handleUnaryCall<GetPaymentRequest, GetPaymentResponse>;
  /** Health check endpoint */
  healthCheck: handleUnaryCall<HealthCheckRequest, HealthCheckResponse>;
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
