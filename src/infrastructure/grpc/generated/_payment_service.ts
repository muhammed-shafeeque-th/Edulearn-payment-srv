// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.33.0
// source: _payment_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import {
  type handleUnaryCall,
  type UntypedServiceImplementation,
} from '@grpc/grpc-js';
import { GrpcMethod, GrpcStreamMethod } from '@nestjs/microservices';
import { Observable } from 'rxjs';

export const protobufPackage = 'payment_service';

/** Structured error message */
export interface Error {
  /** e.g., "RESOURCE_NOT_FOUND", "INVALID_ARGUMENT", "UNAUTHENTICATED" */
  code: string;
  /** Human-readable error message */
  message: string;
  /** Optional detailed error information */
  details: ErrorDetail[];
}

/** Detailed error information */
export interface ErrorDetail {
  /** Field name that caused the error */
  field: string;
  /** Field-specific error message */
  message: string;
}

/** Money message to represent monetary values */
export interface Money {
  /** Amount in the smallest unit (e.g., cents) */
  amount: number;
  /** ISO 4217 currency code (e.g., "USD") */
  currency: string;
}

/** Request to process a payment */
export interface CreatePaymentRequest {
  userId: string;
  orderId: string;
  successUrl?: string | undefined;
  cancelUrl?: string | undefined;
  amount: Money | undefined;
  /** e.g., "stripe", "paypal" */
  paymentGateway: string;
  /** For ensuring idempotency */
  idempotencyKey: string;
}

/** Request to process a payment capture */
export interface CapturePaymentRequest {
  userId: string;
  paymentId: string;
  providerOrderId: string;
}

/** Response to process a payment capture */
export interface CapturePaymentSuccess {
  transactionId: string;
  paymentId: string;
  status: string;
  metadata: { [key: string]: string };
}

export interface CapturePaymentSuccess_MetadataEntry {
  key: string;
  value: string;
}

export interface RazorpayVerifyPaymentRequest {
  razorpayPaymentId: string;
  paymentId: string;
  razorpayOrderId: string;
  razorpaySignature: string;
}

/** Response to process a payment verify */
export interface RazorpayVerifyPaymentSuccess {
  paymentId: string;
  transactionId: string;
  status: string;
  metadata: { [key: string]: string };
}

export interface RazorpayVerifyPaymentSuccess_MetadataEntry {
  key: string;
  value: string;
}

/** Success message for payment process */
export interface StripeCreateSuccess {
  paymentId: string;
  userId: string;
  orderId: string;
  clientSecret: string;
  amount: Money | undefined;
  /** e.g., "SUCCESS", "PENDING", "FAILED" */
  status: string;
  /** Gateway-specific transaction ID */
  transactionId: string;
}

export interface RazorpayCreateSuccess {
  paymentId: string;
  userId: string;
  orderId: string;
  providerOrderId: string;
  amount: Money | undefined;
  /** e.g., "SUCCESS", "PENDING", "FAILED" */
  status: string;
  /** Gateway-specific transaction ID */
  keyId: string;
}

export interface PayPalCreateSuccess {
  paymentId: string;
  userId: string;
  orderId: string;
  providerOrderId: string;
  amount: Money | undefined;
  /** e.g., "SUCCESS", "PENDING", "FAILED" */
  status: string;
  /** Gateway-specific transaction ID */
  approvalUrl: string;
}

/** Response for a payment process */
export interface CreatePaymentResponse {
  success?: CreatePaymentSuccess | undefined;
  error?: Error | undefined;
}

export interface CreatePaymentSuccess {
  stripe?: StripeCreateSuccess | undefined;
  razorpay?: RazorpayCreateSuccess | undefined;
  paypal?: PayPalCreateSuccess | undefined;
}

/** Request to process a refund */
export interface ProcessRefundRequest {
  paymentId: string;
  userId: string;
  amount: Money | undefined;
  reason: string;
  idempotencyKey: string;
}

/** Success message for refund process */
export interface ProcessRefundSuccess {
  refundId: string;
  paymentId: string;
  userId: string;
  amount: Money | undefined;
  /** e.g., "SUCCESS", "PENDING", "FAILED" */
  status: string;
  /** Gateway-specific transaction ID */
  transactionId: string;
}

/** Response for a refund process */
export interface ProcessRefundResponse {
  success?: ProcessRefundSuccess | undefined;
  error?: Error | undefined;
}

export interface CapturePaymentResponse {
  success?: CapturePaymentSuccess | undefined;
  error?: Error | undefined;
}

export interface RazorpayVerifyResponse {
  success?: RazorpayVerifyPaymentSuccess | undefined;
  error?: Error | undefined;
}

/** Health check request (for monitoring) */
export interface HealthCheckRequest {}

/** Health check response */
export interface HealthCheckResponse {
  /** e.g., "HEALTHY", "UNHEALTHY" */
  status: string;
}

export const PAYMENT_SERVICE_PACKAGE_NAME = 'payment_service';

function createBaseError(): Error {
  return { code: '', message: '', details: [] };
}

export const Error: MessageFns<Error> = {
  encode(
    message: Error,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.code !== '') {
      writer.uint32(10).string(message.code);
    }
    if (message.message !== '') {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.details) {
      ErrorDetail.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Error {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.details.push(ErrorDetail.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseErrorDetail(): ErrorDetail {
  return { field: '', message: '' };
}

export const ErrorDetail: MessageFns<ErrorDetail> = {
  encode(
    message: ErrorDetail,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.field !== '') {
      writer.uint32(10).string(message.field);
    }
    if (message.message !== '') {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorDetail {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMoney(): Money {
  return { amount: 0, currency: '' };
}

export const Money: MessageFns<Money> = {
  encode(
    message: Money,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.amount !== 0) {
      writer.uint32(8).int64(message.amount);
    }
    if (message.currency !== '') {
      writer.uint32(18).string(message.currency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Money {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoney();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreatePaymentRequest(): CreatePaymentRequest {
  return {
    userId: '',
    orderId: '',
    amount: undefined,
    paymentGateway: '',
    idempotencyKey: '',
  };
}

export const CreatePaymentRequest: MessageFns<CreatePaymentRequest> = {
  encode(
    message: CreatePaymentRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.orderId !== '') {
      writer.uint32(18).string(message.orderId);
    }
    if (message.successUrl !== undefined) {
      writer.uint32(58).string(message.successUrl);
    }
    if (message.cancelUrl !== undefined) {
      writer.uint32(66).string(message.cancelUrl);
    }
    if (message.amount !== undefined) {
      Money.encode(message.amount, writer.uint32(26).fork()).join();
    }
    if (message.paymentGateway !== '') {
      writer.uint32(34).string(message.paymentGateway);
    }
    if (message.idempotencyKey !== '') {
      writer.uint32(42).string(message.idempotencyKey);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CreatePaymentRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.successUrl = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.cancelUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = Money.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.paymentGateway = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCapturePaymentRequest(): CapturePaymentRequest {
  return { userId: '', paymentId: '', providerOrderId: '' };
}

export const CapturePaymentRequest: MessageFns<CapturePaymentRequest> = {
  encode(
    message: CapturePaymentRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.paymentId !== '') {
      writer.uint32(26).string(message.paymentId);
    }
    if (message.providerOrderId !== '') {
      writer.uint32(18).string(message.providerOrderId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CapturePaymentRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCapturePaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerOrderId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCapturePaymentSuccess(): CapturePaymentSuccess {
  return { transactionId: '', paymentId: '', status: '', metadata: {} };
}

export const CapturePaymentSuccess: MessageFns<CapturePaymentSuccess> = {
  encode(
    message: CapturePaymentSuccess,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.transactionId !== '') {
      writer.uint32(10).string(message.transactionId);
    }
    if (message.paymentId !== '') {
      writer.uint32(42).string(message.paymentId);
    }
    if (message.status !== '') {
      writer.uint32(18).string(message.status);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      CapturePaymentSuccess_MetadataEntry.encode(
        { key: key as any, value },
        writer.uint32(26).fork(),
      ).join();
    });
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CapturePaymentSuccess {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCapturePaymentSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = CapturePaymentSuccess_MetadataEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCapturePaymentSuccess_MetadataEntry(): CapturePaymentSuccess_MetadataEntry {
  return { key: '', value: '' };
}

export const CapturePaymentSuccess_MetadataEntry: MessageFns<CapturePaymentSuccess_MetadataEntry> =
  {
    encode(
      message: CapturePaymentSuccess_MetadataEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== '') {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== '') {
        writer.uint32(18).string(message.value);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): CapturePaymentSuccess_MetadataEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCapturePaymentSuccess_MetadataEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseRazorpayVerifyPaymentRequest(): RazorpayVerifyPaymentRequest {
  return {
    razorpayPaymentId: '',
    paymentId: '',
    razorpayOrderId: '',
    razorpaySignature: '',
  };
}

export const RazorpayVerifyPaymentRequest: MessageFns<RazorpayVerifyPaymentRequest> =
  {
    encode(
      message: RazorpayVerifyPaymentRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.razorpayPaymentId !== '') {
        writer.uint32(10).string(message.razorpayPaymentId);
      }
      if (message.paymentId !== '') {
        writer.uint32(42).string(message.paymentId);
      }
      if (message.razorpayOrderId !== '') {
        writer.uint32(18).string(message.razorpayOrderId);
      }
      if (message.razorpaySignature !== '') {
        writer.uint32(26).string(message.razorpaySignature);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): RazorpayVerifyPaymentRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseRazorpayVerifyPaymentRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.razorpayPaymentId = reader.string();
            continue;
          }
          case 5: {
            if (tag !== 42) {
              break;
            }

            message.paymentId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.razorpayOrderId = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.razorpaySignature = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseRazorpayVerifyPaymentSuccess(): RazorpayVerifyPaymentSuccess {
  return { paymentId: '', transactionId: '', status: '', metadata: {} };
}

export const RazorpayVerifyPaymentSuccess: MessageFns<RazorpayVerifyPaymentSuccess> =
  {
    encode(
      message: RazorpayVerifyPaymentSuccess,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.paymentId !== '') {
        writer.uint32(42).string(message.paymentId);
      }
      if (message.transactionId !== '') {
        writer.uint32(10).string(message.transactionId);
      }
      if (message.status !== '') {
        writer.uint32(18).string(message.status);
      }
      Object.entries(message.metadata).forEach(([key, value]) => {
        RazorpayVerifyPaymentSuccess_MetadataEntry.encode(
          { key: key as any, value },
          writer.uint32(26).fork(),
        ).join();
      });
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): RazorpayVerifyPaymentSuccess {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseRazorpayVerifyPaymentSuccess();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 5: {
            if (tag !== 42) {
              break;
            }

            message.paymentId = reader.string();
            continue;
          }
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.transactionId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.status = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            const entry3 = RazorpayVerifyPaymentSuccess_MetadataEntry.decode(
              reader,
              reader.uint32(),
            );
            if (entry3.value !== undefined) {
              message.metadata[entry3.key] = entry3.value;
            }
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseRazorpayVerifyPaymentSuccess_MetadataEntry(): RazorpayVerifyPaymentSuccess_MetadataEntry {
  return { key: '', value: '' };
}

export const RazorpayVerifyPaymentSuccess_MetadataEntry: MessageFns<RazorpayVerifyPaymentSuccess_MetadataEntry> =
  {
    encode(
      message: RazorpayVerifyPaymentSuccess_MetadataEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== '') {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== '') {
        writer.uint32(18).string(message.value);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): RazorpayVerifyPaymentSuccess_MetadataEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseRazorpayVerifyPaymentSuccess_MetadataEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseStripeCreateSuccess(): StripeCreateSuccess {
  return {
    paymentId: '',
    userId: '',
    orderId: '',
    clientSecret: '',
    amount: undefined,
    status: '',
    transactionId: '',
  };
}

export const StripeCreateSuccess: MessageFns<StripeCreateSuccess> = {
  encode(
    message: StripeCreateSuccess,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.paymentId !== '') {
      writer.uint32(10).string(message.paymentId);
    }
    if (message.userId !== '') {
      writer.uint32(18).string(message.userId);
    }
    if (message.orderId !== '') {
      writer.uint32(26).string(message.orderId);
    }
    if (message.clientSecret !== '') {
      writer.uint32(58).string(message.clientSecret);
    }
    if (message.amount !== undefined) {
      Money.encode(message.amount, writer.uint32(34).fork()).join();
    }
    if (message.status !== '') {
      writer.uint32(42).string(message.status);
    }
    if (message.transactionId !== '') {
      writer.uint32(50).string(message.transactionId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): StripeCreateSuccess {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeCreateSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = Money.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRazorpayCreateSuccess(): RazorpayCreateSuccess {
  return {
    paymentId: '',
    userId: '',
    orderId: '',
    providerOrderId: '',
    amount: undefined,
    status: '',
    keyId: '',
  };
}

export const RazorpayCreateSuccess: MessageFns<RazorpayCreateSuccess> = {
  encode(
    message: RazorpayCreateSuccess,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.paymentId !== '') {
      writer.uint32(10).string(message.paymentId);
    }
    if (message.userId !== '') {
      writer.uint32(18).string(message.userId);
    }
    if (message.orderId !== '') {
      writer.uint32(26).string(message.orderId);
    }
    if (message.providerOrderId !== '') {
      writer.uint32(58).string(message.providerOrderId);
    }
    if (message.amount !== undefined) {
      Money.encode(message.amount, writer.uint32(34).fork()).join();
    }
    if (message.status !== '') {
      writer.uint32(42).string(message.status);
    }
    if (message.keyId !== '') {
      writer.uint32(50).string(message.keyId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): RazorpayCreateSuccess {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRazorpayCreateSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.providerOrderId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = Money.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.keyId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePayPalCreateSuccess(): PayPalCreateSuccess {
  return {
    paymentId: '',
    userId: '',
    orderId: '',
    providerOrderId: '',
    amount: undefined,
    status: '',
    approvalUrl: '',
  };
}

export const PayPalCreateSuccess: MessageFns<PayPalCreateSuccess> = {
  encode(
    message: PayPalCreateSuccess,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.paymentId !== '') {
      writer.uint32(10).string(message.paymentId);
    }
    if (message.userId !== '') {
      writer.uint32(18).string(message.userId);
    }
    if (message.orderId !== '') {
      writer.uint32(26).string(message.orderId);
    }
    if (message.providerOrderId !== '') {
      writer.uint32(58).string(message.providerOrderId);
    }
    if (message.amount !== undefined) {
      Money.encode(message.amount, writer.uint32(34).fork()).join();
    }
    if (message.status !== '') {
      writer.uint32(42).string(message.status);
    }
    if (message.approvalUrl !== '') {
      writer.uint32(50).string(message.approvalUrl);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): PayPalCreateSuccess {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalCreateSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.providerOrderId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = Money.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.approvalUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreatePaymentResponse(): CreatePaymentResponse {
  return {};
}

export const CreatePaymentResponse: MessageFns<CreatePaymentResponse> = {
  encode(
    message: CreatePaymentResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== undefined) {
      CreatePaymentSuccess.encode(
        message.success,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CreatePaymentResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = CreatePaymentSuccess.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreatePaymentSuccess(): CreatePaymentSuccess {
  return {};
}

export const CreatePaymentSuccess: MessageFns<CreatePaymentSuccess> = {
  encode(
    message: CreatePaymentSuccess,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.stripe !== undefined) {
      StripeCreateSuccess.encode(
        message.stripe,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.razorpay !== undefined) {
      RazorpayCreateSuccess.encode(
        message.razorpay,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.paypal !== undefined) {
      PayPalCreateSuccess.encode(
        message.paypal,
        writer.uint32(26).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CreatePaymentSuccess {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePaymentSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stripe = StripeCreateSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.razorpay = RazorpayCreateSuccess.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paypal = PayPalCreateSuccess.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProcessRefundRequest(): ProcessRefundRequest {
  return {
    paymentId: '',
    userId: '',
    amount: undefined,
    reason: '',
    idempotencyKey: '',
  };
}

export const ProcessRefundRequest: MessageFns<ProcessRefundRequest> = {
  encode(
    message: ProcessRefundRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.paymentId !== '') {
      writer.uint32(10).string(message.paymentId);
    }
    if (message.userId !== '') {
      writer.uint32(18).string(message.userId);
    }
    if (message.amount !== undefined) {
      Money.encode(message.amount, writer.uint32(26).fork()).join();
    }
    if (message.reason !== '') {
      writer.uint32(34).string(message.reason);
    }
    if (message.idempotencyKey !== '') {
      writer.uint32(42).string(message.idempotencyKey);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ProcessRefundRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessRefundRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = Money.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProcessRefundSuccess(): ProcessRefundSuccess {
  return {
    refundId: '',
    paymentId: '',
    userId: '',
    amount: undefined,
    status: '',
    transactionId: '',
  };
}

export const ProcessRefundSuccess: MessageFns<ProcessRefundSuccess> = {
  encode(
    message: ProcessRefundSuccess,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.refundId !== '') {
      writer.uint32(10).string(message.refundId);
    }
    if (message.paymentId !== '') {
      writer.uint32(18).string(message.paymentId);
    }
    if (message.userId !== '') {
      writer.uint32(26).string(message.userId);
    }
    if (message.amount !== undefined) {
      Money.encode(message.amount, writer.uint32(34).fork()).join();
    }
    if (message.status !== '') {
      writer.uint32(42).string(message.status);
    }
    if (message.transactionId !== '') {
      writer.uint32(50).string(message.transactionId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ProcessRefundSuccess {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessRefundSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refundId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = Money.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProcessRefundResponse(): ProcessRefundResponse {
  return {};
}

export const ProcessRefundResponse: MessageFns<ProcessRefundResponse> = {
  encode(
    message: ProcessRefundResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== undefined) {
      ProcessRefundSuccess.encode(
        message.success,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ProcessRefundResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessRefundResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = ProcessRefundSuccess.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCapturePaymentResponse(): CapturePaymentResponse {
  return {};
}

export const CapturePaymentResponse: MessageFns<CapturePaymentResponse> = {
  encode(
    message: CapturePaymentResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== undefined) {
      CapturePaymentSuccess.encode(
        message.success,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CapturePaymentResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCapturePaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = CapturePaymentSuccess.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRazorpayVerifyResponse(): RazorpayVerifyResponse {
  return {};
}

export const RazorpayVerifyResponse: MessageFns<RazorpayVerifyResponse> = {
  encode(
    message: RazorpayVerifyResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== undefined) {
      RazorpayVerifyPaymentSuccess.encode(
        message.success,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): RazorpayVerifyResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRazorpayVerifyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = RazorpayVerifyPaymentSuccess.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return {};
}

export const HealthCheckRequest: MessageFns<HealthCheckRequest> = {
  encode(
    _: HealthCheckRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): HealthCheckRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { status: '' };
}

export const HealthCheckResponse: MessageFns<HealthCheckResponse> = {
  encode(
    message: HealthCheckResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.status !== '') {
      writer.uint32(10).string(message.status);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): HealthCheckResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

/** Payment Service definition */

export interface PaymentServiceClient {
  /** Process a payment for an order */

  createPayment(
    request: CreatePaymentRequest,
  ): Observable<CreatePaymentResponse>;

  payPalPaymentCapture(
    request: CapturePaymentRequest,
  ): Observable<CapturePaymentResponse>;

  razorpayVerifyPayment(
    request: RazorpayVerifyPaymentRequest,
  ): Observable<RazorpayVerifyResponse>;

  /** Process a refund for a payment */

  processRefund(
    request: ProcessRefundRequest,
  ): Observable<ProcessRefundResponse>;

  /** Health check endpoint */

  healthCheck(request: HealthCheckRequest): Observable<HealthCheckResponse>;
}

/** Payment Service definition */

export interface PaymentServiceController {
  /** Process a payment for an order */

  createPayment(
    request: CreatePaymentRequest,
  ):
    | Promise<CreatePaymentResponse>
    | Observable<CreatePaymentResponse>
    | CreatePaymentResponse;

  payPalPaymentCapture(
    request: CapturePaymentRequest,
  ):
    | Promise<CapturePaymentResponse>
    | Observable<CapturePaymentResponse>
    | CapturePaymentResponse;

  razorpayVerifyPayment(
    request: RazorpayVerifyPaymentRequest,
  ):
    | Promise<RazorpayVerifyResponse>
    | Observable<RazorpayVerifyResponse>
    | RazorpayVerifyResponse;

  /** Process a refund for a payment */

  processRefund(
    request: ProcessRefundRequest,
  ):
    | Promise<ProcessRefundResponse>
    | Observable<ProcessRefundResponse>
    | ProcessRefundResponse;

  /** Health check endpoint */

  healthCheck(
    request: HealthCheckRequest,
  ):
    | Promise<HealthCheckResponse>
    | Observable<HealthCheckResponse>
    | HealthCheckResponse;
}

export function PaymentServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      'createPayment',
      'payPalPaymentCapture',
      'razorpayVerifyPayment',
      'processRefund',
      'healthCheck',
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(
        constructor.prototype,
        method,
      );
      GrpcMethod('PaymentService', method)(
        constructor.prototype[method],
        method,
        descriptor,
      );
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(
        constructor.prototype,
        method,
      );
      GrpcStreamMethod('PaymentService', method)(
        constructor.prototype[method],
        method,
        descriptor,
      );
    }
  };
}

export const PAYMENT_SERVICE_NAME = 'PaymentService';

/** Payment Service definition */
export type PaymentServiceService = typeof PaymentServiceService;
export const PaymentServiceService = {
  /** Process a payment for an order */
  createPayment: {
    path: '/payment_service.PaymentService/CreatePayment',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePaymentRequest) =>
      Buffer.from(CreatePaymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreatePaymentRequest.decode(value),
    responseSerialize: (value: CreatePaymentResponse) =>
      Buffer.from(CreatePaymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreatePaymentResponse.decode(value),
  },
  payPalPaymentCapture: {
    path: '/payment_service.PaymentService/PayPalPaymentCapture',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CapturePaymentRequest) =>
      Buffer.from(CapturePaymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CapturePaymentRequest.decode(value),
    responseSerialize: (value: CapturePaymentResponse) =>
      Buffer.from(CapturePaymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      CapturePaymentResponse.decode(value),
  },
  razorpayVerifyPayment: {
    path: '/payment_service.PaymentService/RazorpayVerifyPayment',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RazorpayVerifyPaymentRequest) =>
      Buffer.from(RazorpayVerifyPaymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) =>
      RazorpayVerifyPaymentRequest.decode(value),
    responseSerialize: (value: RazorpayVerifyResponse) =>
      Buffer.from(RazorpayVerifyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) =>
      RazorpayVerifyResponse.decode(value),
  },
  /** Process a refund for a payment */
  processRefund: {
    path: '/payment_service.PaymentService/ProcessRefund',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProcessRefundRequest) =>
      Buffer.from(ProcessRefundRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ProcessRefundRequest.decode(value),
    responseSerialize: (value: ProcessRefundResponse) =>
      Buffer.from(ProcessRefundResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ProcessRefundResponse.decode(value),
  },
  /** Health check endpoint */
  healthCheck: {
    path: '/payment_service.PaymentService/HealthCheck',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HealthCheckRequest) =>
      Buffer.from(HealthCheckRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => HealthCheckRequest.decode(value),
    responseSerialize: (value: HealthCheckResponse) =>
      Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthCheckResponse.decode(value),
  },
} as const;

export interface PaymentServiceServer extends UntypedServiceImplementation {
  /** Process a payment for an order */
  createPayment: handleUnaryCall<CreatePaymentRequest, CreatePaymentResponse>;
  payPalPaymentCapture: handleUnaryCall<
    CapturePaymentRequest,
    CapturePaymentResponse
  >;
  razorpayVerifyPayment: handleUnaryCall<
    RazorpayVerifyPaymentRequest,
    RazorpayVerifyResponse
  >;
  /** Process a refund for a payment */
  processRefund: handleUnaryCall<ProcessRefundRequest, ProcessRefundResponse>;
  /** Health check endpoint */
  healthCheck: handleUnaryCall<HealthCheckRequest, HealthCheckResponse>;
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER');
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error('Value is smaller than Number.MIN_SAFE_INTEGER');
  }
  return num;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
